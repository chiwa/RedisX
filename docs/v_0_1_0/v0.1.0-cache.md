# RedisX Starter (Cache Core พร้อม Condition/Unless)

> **Features**
>
> -   `@CacheableX` -- Read-through cache + TTL
> -   `condition` / `unless` บน `@CacheableX` -- เงื่อนไขก่อน/หลัง
> -   `@CacheEvictX` -- ลบ cache รายคีย์/ทั้งกลุ่ม
> -   `@MapCachePut` / `@MapCacheGet` -- Map/Hash cache
> -   `@MapCacheEvict` -- ลบ field / ลบทั้ง hash group
>
> (ทั้งหมดมี **auto-config** ผ่าน Spring Boot Starter)

------------------------------------------------------------------------

## ที่มาที่ไป

ระบบจริงต้องการมากกว่าแค่ "อ่าน/เขียน" cache:

-   ต้องมี **เงื่อนไขยืดหยุ่น** เช่น *ไม่ cache สำหรับ ADMIN*, *ไม่
    cache ค่า null* ฯลฯ
-   ต้องออกแบบคีย์ให้ชัดเจน (Composite, Object-based) เพื่อป้องกัน key
    collision
-   ต้องรองรับ **Hash Cache (MapCache)** เพื่อ grouping key/value
    หลายตัวในคีย์เดียว → ง่ายต่อการ expire/lifecycle

ดังนั้น v0.1.0 จึงรวม Condition/Unless + Evict + MapCache มาให้ครบ
เพื่อใช้งาน production ได้ทันที และยังคงแนวคิด **Annotation-first** ให้
dev โฟกัสที่ business logic

------------------------------------------------------------------------

## 1) ใช้อย่างไร (Quick Start)

**ติดตั้ง**

``` xml
<dependency>
  <groupId>com.zengcode.redisx</groupId>
  <artifactId>redisx-cache-starter</artifactId>
  <version>0.1.0</version>
</dependency>
```

**ตั้งค่า Redis (ตัวอย่าง dev)**

``` yaml
spring:
  data:
    redis:
      host: localhost
      port: 6379

redisx:
  cache:
    prefix: zengcache
    enabled: true
```

**ตัวอย่างใช้งาน 30 วิ**

``` java
@Service
class ProductService {
  // อ่านผ่าน cache (read-through) 5 นาที, key = zengcache:product:{id}
  @CacheableX(cacheName = "product", key = "#id", ttlSeconds = 300,
              condition = "#id != 'ADMIN'",   // ADMIN ไม่ใช้ cache
              unless = "#result == null")     // ถ้าผลลัพธ์ null ไม่เขียน cache
  public ProductDto get(String id) { return repo.findById(id); }

  // อัปเดตข้อมูล → ลบ cache ออก
  @CacheEvictX(cacheName = "product", key = "#id")
  public void update(String id, ProductDto dto) { repo.save(id, dto); }
}
```

------------------------------------------------------------------------

## 2) API Contracts

### 2.1 `@CacheableX`

``` java
@CacheableX(
  cacheName = "...",    // กลุ่ม cache (prefix)
  key = "...",          // SpEL → คีย์ต่อท้าย
  ttlSeconds = 300,     // อายุ cache
  condition = "",       // (optional) true → ใช้ cache; false → bypass
  unless = ""           // (optional) true → veto ไม่เขียน cache (หลังได้ #result)
)
```

**พฤติกรรม** \* เช็ค `condition` ก่อน: ถ้า false → bypass
(ไม่อ่าน/ไม่เขียน cache) \* ถ้า true → ลองอ่าน cache; ถ้า miss →
เรียกเมธอด \* หลังได้ผลลัพธ์ → เช็ค `unless` (true = ไม่เขียน cache) \*
คีย์จริง: `{prefix}:{cacheName}:{evaluatedKey}`

------------------------------------------------------------------------

### 2.2 `@CacheEvictX`

``` java
@CacheEvictX(
  cacheName = "...",
  key = "...",     // optional
  allEntries = false
)
```

-   ถ้า `allEntries=false` → ลบคีย์เดียว
-   ถ้า `allEntries=true` → scan & ลบทั้ง group

------------------------------------------------------------------------

### 2.3 `@MapCachePut`

``` java
@MapCachePut(
  cacheName = "...",   // hash key
  key = "...",         // field
  ttlSeconds = 60
)
```

-   put result ลงใน Hash (field = evaluatedKey)
-   ตั้ง TTL ที่ระดับ hash key

------------------------------------------------------------------------

### 2.4 `@MapCacheGet`

``` java
@MapCacheGet(
  cacheName = "...",  // hash key
  key = "..."         // field
)
```

-   ดึงค่าจาก Hash field → ถ้า miss → เรียกเมธอด → put cache
    ให้อัตโนมัติ

------------------------------------------------------------------------

### 2.5 `@MapCacheEvict`

``` java
@MapCacheEvict(
  cacheName = "...",  // hash key
  key = "",           // optional field
  allEntries = false  // true → ลบทั้ง hash
)
```

-   ถ้า `key` ระบุ → ลบ field เดียว
-   ถ้า `allEntries=true` → ลบ hash ทั้งก้อน

------------------------------------------------------------------------

## 3) ตัวอย่าง SpEL (Best Practice)

### Composite Key

``` java
@CacheableX(cacheName="order", key="#userId + ':' + #orderId", ttlSeconds=600)
public Order getOrder(String userId, String orderId) { ... }
```

➡️ Key จริง = `zengcache:order:U123:O456`

------------------------------------------------------------------------

### Complex Key จาก Object

``` java
@CacheableX(cacheName="detail", key="'U:' + #user.id + ':O:' + #order.id")
public OrderDetail detail(User user, Order order) { ... }
```

➡️ Key = `zengcache:detail:U:101:O:555`

------------------------------------------------------------------------

### Null-safe / Business Condition

``` java
@CacheableX(cacheName="profile", key="#id", unless="#result == null || #result.inactive")
public Profile profile(String id) { ... }
```

➡️ ถ้า `result == null` หรือ `inactive` → ไม่เขียน cache → ป้องกัน stale
data




