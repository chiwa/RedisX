# RedisX Starter (Cache Core พร้อม Condition/Unless)

> **Features**
>
> * `@CacheableX` – Read-through cache + TTL
> * `condition` / `unless` บน `@CacheableX` – เงื่อนไขก่อน/หลัง
>
> <!-- TODO: จะเปิดฟีเจอร์เพิ่มในอนาคต -->
>
> <!-- * `@CacheEvictX` – ลบ cache รายคีย์/ทั้งกลุ่ม -->
>
> <!-- * `@MapCachePut` / `@MapCacheGet` – Map/Hash cache -->

---

## ที่มาที่ไป

ระบบจริงต้องการมากกว่าแค่ "อ่าน/เขียน" cache:

* ต้องมี **เงื่อนไขยืดหยุ่น** เช่น *ไม่ cache สำหรับ ADMIN*, *ไม่ cache ค่า null* ฯลฯ
* ต้องออกแบบคีย์ให้ชัดเจน (Composite, Object-based) เพื่อป้องกัน key collision

ดังนั้น v0.1.0 จึงรวม Condition/Unless มาให้ครบ เพื่อใช้งาน production ได้ทันที และยังคงแนวคิด **Annotation-first** ให้ dev โฟกัสที่ business logic

---

## 1) ใช้อย่างไร (Quick Start)

**ติดตั้ง**

```xml
<dependency>
  <groupId>com.zengcode.redisx</groupId>
  <artifactId>redisx-cache-starter</artifactId>
  <version>0.1.0</version>
</dependency>
```

**ตั้งค่า Redis (ตัวอย่าง dev)**

```yaml
spring:
  data:
    redis:
      host: localhost
      port: 6379
```

**ตัวอย่างใช้งาน 30 วิ**

```java
@Service
class ProductService {
  // อ่านผ่าน cache (read-through) 5 นาที, key = cache:product:{id}
  @CacheableX(cacheName = "product", key = "#id", ttlSeconds = 300,
              condition = "#id != 'ADMIN'",   // ADMIN ไม่ใช้ cache
              unless = "#result == null")     // ถ้าผลลัพธ์ null ไม่เขียน cache
  public ProductDto get(String id) { return repo.findById(id); }
}
```

---

## 2) API Contracts

### 2.1 `@CacheableX`

```java
@CacheableX(
  cacheName = "...",    // กลุ่ม cache (prefix)
  key = "...",          // SpEL → คีย์ต่อท้าย
  ttlSeconds = 300,     // อายุ cache
  condition = "",       // (optional) true → ใช้ cache; false → bypass
  unless = ""           // (optional) true → veto ไม่เขียน cache (หลังได้ #result)
)
```

**พฤติกรรม**

* เช็ค `condition` ก่อน: ถ้า false → bypass (ไม่อ่าน/ไม่เขียน cache)
* ถ้า true → ลองอ่าน cache; ถ้า miss → เรียกเมธอด
* หลังได้ผลลัพธ์ → เช็ค `unless` (true = ไม่เขียน cache)
* คีย์จริง: `cache:{cacheName}:{evaluatedKey}`

---

## 3) ตัวอย่าง SpEL (Best Practice)

### Composite Key

```java
@CacheableX(cacheName="order", key="#userId + ':' + #orderId", ttlSeconds=600)
public Order getOrder(String userId, String orderId) { ... }
```

➡️ ใช้ parameter หลายตัวมาต่อ string → Key จริง = `cache:order:U123:O456`

---

### Complex Key จาก Object

```java
@CacheableX(cacheName="detail", key="'U:' + #user.id + ':O:' + #order.id")
public OrderDetail detail(User user, Order order) { ... }
```

➡️ ใช้ property ของ object (`user.id`, `order.id`) → Key = `cache:detail:U:101:O:555`

---

### Null-safe / Business Condition

```java
@CacheableX(cacheName="profile", key="#id", unless="#result == null || #result.inactive")
public Profile profile(String id) { ... }
```

➡️ ถ้า `result == null` หรือ `inactive` → ไม่เขียน cache → ป้องกัน stale data

---

<!--
## 4) ฟีเจอร์ที่กำลังจะมา

### `@CacheEvictX` – ลบ cache รายคีย์/ทั้งกลุ่ม
### `@MapCachePut` / `@MapCacheGet` – ใช้ Redis Hash
-->
