# RedisX Starter – v0.1.0 (Cache Core พร้อม Evict + Condition/Unless)


>
> **Features**
>
> * `@CacheableX` – Read‑through cache + TTL
> * `@MapCachePut` / `@MapCacheGet` – Map/Hash cache
> * `@CacheEvictX` – ลบ cache รายคีย์/ทั้งกลุ่ม
> * `condition` / `unless` บน `@CacheableX` – เงื่อนไขก่อน/หลัง

---

## ที่มาที่ไป

ระบบจริงต้องการมากกว่าแค่ "อ่าน/เขียน" cache:

* ต้อง **ลบ cache** เมื่อมีการอัปเดตข้อมูล (evict)
* ต้องมี **เงื่อนไขยืดหยุ่น** เช่น *ไม่ cache สำหรับ ADMIN*, *ไม่ cache ค่า null* ฯลฯ
  ดังนั้น v0.1.0 จึงรวม Evict และ Condition/Unless มาให้ครบ เพื่อใช้งาน production ได้ทันที และยังคงแนวคิด **Annotation‑first** ให้ dev โฟกัสที่ business logic

---

## 1) ใช้อย่างไร (Quick Start)

**ติดตั้ง**

```xml
<dependency>
  <groupId>com.zengcode.redisx</groupId>
  <artifactId>redisx-cache-starter</artifactId>
  <version>0.1.0</version>
</dependency>
```

**ตั้งค่า Redis (ตัวอย่าง dev)**

```yaml
spring:
  data:
    redis:
      host: localhost
      port: 6379
```

**ตัวอย่างใช้งาน 30 วิ**

```java
@Service
class ProductService {
  // อ่านผ่าน cache (read‑through) 5 นาที, key = cache:product:{id}
  @CacheableX(cacheName = "product", key = "#id", ttlSeconds = 300,
              condition = "#id != 'ADMIN'",   // ADMIN ไม่ใช้ cache
              unless = "#result == null")     // ถ้าผลลัพธ์ null ไม่เขียน cache
  public ProductDto get(String id) { return repo.findById(id); }

  // อัปเดตแล้วล้าง cache ของคีย์เดียวกัน
  @CacheEvictX(cacheName = "product", key = "#id")
  public void update(String id, UpdateProduct cmd) { repo.save(cmd); }
}
```

---

## 2) API Contracts

### 2.1 `@CacheableX`

```java
@CacheableX(
  cacheName = "...",    // กลุ่ม cache (prefix)
  key = "...",          // SpEL → คีย์ต่อท้าย
  ttlSeconds = 300,      // อายุ cache
  condition = "",       // (optional) true → ใช้ cache; false → bypass
  unless = ""           // (optional) true → veto ไม่เขียน cache (หลังได้ #result)
)
```

**พฤติกรรม**

* เช็ค `condition` ก่อน: ถ้า false → bypass (ไม่อ่าน/ไม่เขียน cache)
* ถ้า true → ลองอ่าน cache; ถ้า miss → เรียกเมธอด
* หลังได้ผลลัพธ์ → เช็ค `unless` (true = ไม่เขียน cache)
* คีย์จริง: `cache:{cacheName}:{evaluatedKey}`

**ตัวอย่าง SpEL ที่พบบ่อย**

```java
// Composite key
@CacheableX(cacheName="order", key="#userId + ':' + #orderId", ttlSeconds=600)
public Order getOrder(String userId, String orderId) { ... }

// Complex SpEL จาก object
@CacheableX(cacheName="detail", key="'U:' + #user.id + ':O:' + #order.id")
public OrderDetail detail(User user, Order order) { ... }

// Null‑safe
@CacheableX(cacheName="profile", key="#id", unless="#result == null || #result.inactive")
public Profile profile(String id) { ... }
```

### 2.2 `@CacheEvictX`

```java
@CacheEvictX(
  cacheName = "...",   // กลุ่ม cache ที่จะลบ
  key = "",            // (optional) SpEL คีย์ที่จะลบ (ใช้เมื่อ allEntries=false)
  allEntries = false,   // true = ลบทั้งกลุ่ม (prefix cacheName)
  beforeInvoke = false  // true = ลบก่อนเรียกเมธอด; false = ลบหลังสำเร็จ
)
```

**ตัวอย่าง**

```java
// ลบรายคีย์ (จับคู่กับ @CacheableX key เดียวกัน)
@CacheEvictX(cacheName="product", key="#id")
public void updateProduct(String id, UpdateProduct cmd) { repo.save(cmd); }

// ลบทั้งกลุ่ม — เหมาะ batch/migration (ลบก่อนทำงาน)
@CacheEvictX(cacheName="catalog", allEntries = true, beforeInvoke = true)
public void importCatalog(MultipartFile file) { service.import(file); }
```

> ใต้ฝา: `allEntries` ใช้ SCAN + DEL (batch) เพื่อเลี่ยงการบล็อกจาก `KEYS`

### 2.3 `@MapCachePut` / `@MapCacheGet`

* ใช้ Redis Hash: คีย์หลัก `map:{name}` + field=`key`
* เหมาะกับ snapshot ย่อย/ค่า field‑like

```java
@MapCachePut(name="price", key="#id",
             value="T(java.util.Map).of('id',#id,'price',#price)", ttlSeconds=600)
public void setPrice(String id, int price) {}

@MapCacheGet(name="price", key="#id")
public Map<String,Object> getPrice(String id) { return Map.of("id", id, "price", 0); }
```

---

## 3) แนวทางออกแบบคีย์ (Keying Guide)

* ใช้ namespace ชัดเจน: \`svc:{domain}:{entity}:{id}
